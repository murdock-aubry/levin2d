!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!  This module contains code for constructing expansions of a nonoscillatory phase function 
!  which represents the Bessel functions of the first and second kinds.  More explicitly,
!  the phase function alpha_dnu(t) is related to the Bessel functions via the formulas
!
!                                 sin ( alpha_dnu (x) )   
!    J  (z) \sqrt(Pi/2 z) =      -----------------------                                  (1)
!     dnu                         sqrt( alpha_dnu'(x) )     
!
!  and 
!
!                                 cos ( alpha_dnu (x) )      
!    Y  (z) \sqrt(Pi/2 z) = (-1) ----------------------- ,                                (2)
!     dnu                         sqrt( alpha_dnu'(x) )    
!
!  and it is nonoscillatory in the sense that
!
!        1                Pi  (  2         2     )
!    -------------    =  ---  ( Y (z)   + J  (z) )
!     alpha_dnu'(t)       2z  (  dnu       dnu   )
!
!  is completely monotonic on the interval (0,\infty).
!
!  The following subroutines should be regarded as publicly callable:
!
!    besphase_init - populate the structure containing all of the data needed by
!      the other routines in this module
!
!
!    besphase_one - construct piecewise univariate Chebyshev expansions representing
!      the phase function alpha_dnu(t) and its first two derivatives for a fixed
!      value of dnu >= 1
!
!    besphase_one_interval - return the extents of the interval over which the expansions
!      generated by besphase_one are given
!
!    besphase_one_eval - given the data generated by besphase_one, evaluate alpha_dnu(t)
!      and its first derivative at a point in the interval (0,\infty).  
!
!    besphase_one_hankel - evaluate the Hankel transform integral
!
!            \infty
!        \int        J  (\lambda x)  \sqrt(\lambda x) f(x) dx                              (4)
!            0        dnu
!
!     with f(x) a user-supplied function
!
!
!    besphase_one_hankel2 - evaluate the Hankel transform integral
!
!             1
!        \int        J  (\lambda x)  \sqrt(\lambda x) f(x) dx                              (4)
!            0        dnu
!
!     with f(x) a user-supplied function
!
!    besphase_one_yint - evaluate the Hankel transform integral
!
!             \infty
!        \int        Y  (\lambda x)  \sqrt(\lambda x) f(x) dx                              (4)
!            0        dnu
!
!     with f(x) a user-supplied function
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!  Observations / To do :
!
!    - Obviously, write versions of these routines which construct expansions
!      of alpha_dnu(t) for ranges of dnu and t
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

module besphase

use utils
use chebyshev
use chebpw
use riccati_nop
use appell_nop
use levin
use iso_c_binding


type           besphase_vars_t 
type(appell_nop_vars_t)            :: appell_vars
type(riccati_nop_vars_t)           :: riccati_vars
type(levin_vars_t)                 :: levin_vars
end type       besphase_vars_t


interface
subroutine besphase_fun1(n,ts,fs,par1,par2,par3)
implicit double precision (a-h,o-z)
double precision          :: ts(:), fs(:)
end subroutine
end interface


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!  The besphase_one_data structure contains all of the data needed to evaluate a
!  phase function
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

type           besphase_one_data   
double precision                   :: dnu
double precision                   :: a, b
type(chebpw_scheme)                :: chebphase
double precision, allocatable      :: alpha(:), alphader(:), alphader2(:)
end type       besphase_one_data


type           besphase_vars_one_levin_t 
procedure(besphase_fun1), pointer, nopass   :: fun
type(besphase_vars_t), pointer              :: vars
type(besphase_one_data), pointer            :: besone
double precision                            :: par1, par2, par3
double precision                            :: dlambda
double precision                            :: a, b
end type       besphase_vars_one_levin_t


contains

subroutine besphase_init(vars)
implicit double precision (a-h,o-z)
type(besphase_vars_t)              :: vars
!
!  Initialize the ODE solvers used by this code.
!
!  Input parameters: 
!    N/A
!
!  Output parameters:  
!    vars - the structure 
!

call appell_nop_init(vars%appell_vars)
call riccati_nop_init(vars%riccati_vars)
call levin_init(vars%levin_vars)

end subroutine


subroutine besphase_one(vars,ier,eps,dnu,besone)
implicit double precision (a-h,o-z)
type(besphase_vars_t)                                :: vars
type(besphase_one_data), intent(out)                 :: besone
!
!  Construct piecewise Chebyshev expansions of the phase function alpha(t)
!  and its first two derivatives for a fixed value of dnu which allow
!  it to be evaluated for in (0,\infty).
!
!  In fact, the expansions produced by this routine are given over an interval
!  of the form [a,100*dnu] with a chosen so that alpha'(a) is extremely small.
!
!  For values of t < a, the evaluation return alpha(t) = alpha'(t) = alpha''(t) = 0.
!
!  For values of t > b, an asymptotic expansion is used to evaluate alpha(t)
!  and its derivatives.
!
!  WARNING: THIS ROUTINE IS ONLY GUARENTEED TO WORK FOR DNU>=1.
!
!  Input parameters:
!    vars - the structure initialized by the besphase_init
!    eps - the precision for the ODE solver used to construct the phase function
!    dnu - the order of the Bessel functions represented by the phase function
!
!  Output parameters:
!    ier - an error return code;
!      ier = 0   indicates successful execution
!      ier = 4   means that the ODE solver used to construct the phase function
!                failed
!
!   besone - a structure containing the expansions needed to evaluate the phase
!     function alpha_dnu(t) for a particular value of dnu
!

double complex                                     :: ima
data pi / 3.14159265358979323846264338327950288d0 /
double precision, allocatable                      :: ab0(:,:)

ier  = 0 
ima  = (0.0d0,1.0d0)

!
!  Use an asymptotic expansion to get the initial values of alpha'(b) and alpha''(b)
!

a = 1.0d-300
b = max(100.0d0,100*dnu)

! if (dnu .lt. 1.0d0) a = 1.0d-60

! nn      = 150
! nints0  = nn+1

! allocate(ab0(2,nints0))
! ab0 = 0

! do int=1,nn
! ab0(1,int) = 10.0d0**(-nn+int-1)
! ab0(2,int) = 10.0d0**(-nn+int)
! end do

! ab0(1,nints0) = 1.0d0
! ab0(2,nints0) = b

call besphase_asym(dnu,b,aval,apval,appval)

!
!  Construct a representation of the phase function
if (dnu .gt. 0.25d0) then
c     = a
aval0 = 0.0d0
else
c     = b
aval0 = aval
endif

call appell_nop_phase(vars%appell_vars,jer,eps,a,b,b,apval,appval,c,aval0,    &
  besphase_coefs,dnu,par2,par3,besone%chebphase,besone%alpha,besone%alphader, &
  besone%alphader2)


if (jer .ne. 0) then
ier = 4
return
endif

call chebpw_interval(besone%chebphase,a,b)


besone%dnu = dnu
besone%a   = a
besone%b   = b

end subroutine


subroutine besphase_one_interval(vars,besone,a,b)
implicit double precision (a-h,o-z)
type(besphase_vars_t)         :: vars
type(besphase_one_data)       :: besone
!
!  Return the extents of the interval over which the expansions generated by
!  besone are given.
!
!  Input parameters:
!    vars - the structure initialized by the besphase_init
!    besone - the structure returned by besphase_one
!
!  Output parameters:
!    (a,b) - the interval
!

a = besone%a
b = besone%b

end subroutine


subroutine besphase_one_eval(vars,besone,x,aval,apval,appval)
implicit double precision (a-h,o-z)
type(besphase_vars_t)         :: vars
type(besphase_one_data)       :: besone
!
!  Evaluate the phase function alpha_dnu(t) and its first two derivatives at a specified
!  point in the interval (0,\infty) given he expansions generated by besphase_oneeval.
!
!  Input parameters:
!    vars - the structure initialized by the besphase_init
!    besone - the structure returned by besphase_one
!    x - the point at which to evaluate alpha_dnu(t) and its first two derivatives
!
!  Output parameters:
!    aval, apval, appval - the values of the phase function and its first two
!      derivatives at x
!
call chebpw_interval(besone%chebphase,a,b)
!
!  If a x<a, we have an underflow situation.
!

if (x .lt. a) then
aval   = 0
apval  = 0
appval = 0
return
endif

!
!  If x > b, use an asymptotic expansions
!
if (x .gt. b) then
call besphase_asym(besone%dnu,x,aval,apval,appval)
return
endif

!
!  Otherwise, use the expansion.
!
call chebpw_interp(besone%chebphase,besone%alpha,besone%alphader,&
  besone%alphader2,x,aval,apval,appval)

end subroutine


subroutine besphase_one_hankel(vars,besone,ier,eps,dlambda,fun,par1,par2,par3,val)
implicit double precision (a-h,o-z)
type(besphase_vars_t), target         :: vars
type(besphase_one_data),target        :: besone
procedure(besphase_fun1)              :: fun
double precision                      :: val
!
!  Use the expansions constructed by besphase_one to evaluate the integral
!
!            \infty
!        \int        J  (\lambda x)  \sqrt(\lambda x) f(x) dx      
!            0        dnu
!
!  using the adaptive Levin method.  The function f(x) is supplied by the user
!  via an external subroutine.
!
!  The function f(x) must decay at least as fast as 1/x to ensure high-accuracy
!  in the calculated solution.
!
!  Input parameters:
!    vars - the structure populated by besphase_init
!    besone - the structure constructed by besphase_one which contains
!      expansions of the phase function
!    eps - the desired precision for the integral
!    dlambda - the value of lambda
!    fun - an external subroutine supplying the values of f(x)
!    par? - parameters which are passed to fun
!
!  Output parameters:
!    ier - an error return code;
!      ier =  0  indicates successful execution
!      ier =  4  means the Levin method failed
!
!    val - the value of the integral
!

type(c_ptr)                              :: userptr
type(besphase_vars_one_levin_t), pointer :: userdata

data dnorm / 0.797884560802865355879892119868763737d0 /
!  
!  If a is too small, adjust it
!

allocate(userdata)
userptr          = c_loc(userdata)
userdata%vars    =>vars
userdata%besone  => besone
userdata%fun     => fun
userdata%besone  => besone
userdata%dlambda = dlambda
userdata%par1    = par1
userdata%par2    = par2
userdata%par3    = par3
userdata%a       = userdata%besone%a

a = userdata%besone%a/dlambda*1.000001d0
b = 1.0d15/dlambda

call levin_adapsin2(vars%levin_vars,ier,eps,a,b,besphase_one_levin,userptr,val)

val = val * dnorm

end subroutine


subroutine besphase_one_hankel2(vars,besone,ier,eps,dlambda,fun,par1,par2,par3,val)
implicit double precision (a-h,o-z)
type(besphase_vars_t), target         :: vars
type(besphase_one_data),target        :: besone
procedure(besphase_fun1)              :: fun
double precision                      :: val
!
!  Use the expansions constructed by besphase_one to evaluate the integral
!
!            1
!        \int        J  (\lambda x)  \sqrt(\lambda x) f(x) dx      
!            0        dnu
!
!  using the adaptive Levin method.  The function f(x) is supplied by the user
!  via an external subroutine.
!
!  The function f(x) must decay at least as fast as 1/x to ensure high-accuracy
!  in the calculated solution.
!
!  Input parameters:
!    vars - the structure populated by besphase_init
!    besone - the structure constructed by besphase_one which contains
!      expansions of the phase function
!    eps - the desired precision for the integral
!    dlambda - the value of lambda
!    fun - an external subroutine supplying the values of f(x)
!    par? - parameters which are passed to fun
!
!  Output parameters:
!    ier - an error return code;
!      ier =  0  indicates successful execution
!      ier =  4  means the Levin method failed
!
!    val - the value of the integral
!

type(c_ptr)                              :: userptr
type(besphase_vars_one_levin_t), pointer :: userdata

data dnorm / 0.797884560802865355879892119868763737d0 /


!  
!  If a is too small, adjust it
!

allocate(userdata)
userptr          = c_loc(userdata)
userdata%vars    =>vars
userdata%besone  => besone
userdata%fun     => fun
userdata%besone  => besone
userdata%dlambda = dlambda
userdata%par1    = par1
userdata%par2    = par2
userdata%par3    = par3
userdata%a       = userdata%besone%a

a = userdata%besone%a/dlambda*1.00001d0
b = 1.0d0

call levin_adapsin2(vars%levin_vars,ier,eps,a,b,besphase_one_levin,userptr,val)

val = val * dnorm

end subroutine



subroutine besphase_one_yint(vars,besone,ier,eps,dlambda,fun,par1,par2,par3,val)
implicit double precision (a-h,o-z)
type(besphase_vars_t), target         :: vars
type(besphase_one_data),target        :: besone
procedure(besphase_fun1)              :: fun
double precision                      :: val
!
!  Use the expansions constructed by besphase_one to evaluate the integral
!
!            1
!        \int        J  (\lambda x)  \sqrt(\lambda x) f(x) dx      
!            0        dnu
!
!  using the adaptive Levin method.  The function f(x) is supplied by the user
!  via an external subroutine.
!
!  The function f(x) must decay at least as fast as 1/x to ensure high-accuracy
!  in the calculated solution.
!
!  Input parameters:
!    vars - the structure populated by besphase_init
!    besone - the structure constructed by besphase_one which contains
!      expansions of the phase function
!    eps - the desired precision for the integral
!    dlambda - the value of lambda
!    fun - an external subroutine supplying the values of f(x)
!    par? - parameters which are passed to fun
!
!  Output parameters:
!    ier - an error return code;
!      ier =  0  indicates successful execution
!      ier =  4  means the Levin method failed
!
!    val - the value of the integral
!

type(c_ptr)                              :: userptr
type(besphase_vars_one_levin_t), pointer :: userdata

data dnorm / 0.797884560802865355879892119868763737d0 /


!  
!  If a is too small, adjust it
!

allocate(userdata)
userptr          = c_loc(userdata)
userdata%vars    =>vars
userdata%besone  => besone
userdata%fun     => fun
userdata%besone  => besone
userdata%dlambda = dlambda
userdata%par1    = par1
userdata%par2    = par2
userdata%par3    = par3
userdata%a       = userdata%besone%a

a = userdata%besone%a/dlambda*1.000001d0
b = 1.0d15/dlambda

call levin_adapcos2(vars%levin_vars,ier,eps,a,b,besphase_one_levin,userptr,val)

val = val * dnorm

end subroutine


subroutine besphase_one_levin(n,ts,gs,fs,userptr)
implicit double precision (a-h,o-z)
double precision                         :: ts(:), gs(:), fs(:)
type(c_ptr)                              :: userptr
type(besphase_vars_one_levin_t), pointer :: userdata
double precision                         :: hs(n)

call c_f_pointer(userptr,userdata)
call userdata%fun(n,ts,hs,userdata%par1,userdata%par2,userdata%par3)
dlambda = userdata%dlambda
a       = userdata%a

! the rest comes from the phase
do i=1,n
t = ts(i)*dlambda

if (t .lt. a) then
print *,"!!!!!!!!!!!!!!!",t,a
stop
endif

call besphase_one_eval(userdata%vars,userdata%besone,t,aval,apval,appval)


gs(i) = aval
fs(i) = hs(i) / sqrt(apval)


end do

end subroutine




subroutine besphase_coefs(n,ts,qs,qders,dnu,par2,par3)
implicit double precision (a-h,o-z)
double precision         :: ts(:)
double precision         :: qs(:), qders(:)
!
!  Coefficients for the interval (1,\infty)
!


qs    = 1 + (0.25d0 - dnu**2) / ts**2
qders = (-0.50d0 + 2*dnu**2) / ts**3

end subroutine


subroutine besphase_asym(dnu,z,aval,apval,appval)
implicit double precision (a-h,o-z)
!
!  Use asymptotic expansions to evaluate alpha(t) and its first two derivatives
!  at large z.
!
!  These expansions achieve roughly 30 digit accuracy when z >= 100 dnu and
!  double precision accuracy when z >= 10 dnu.
!  
!  Input parameters:
!    dnu - the parameter in Bessel's differential equation
!    z - the point at which to evaluate the phase function
!
!  Output parameters:
!    apval - the value of alpha'(z)
!    appval - the value of alpha''(z)
!
aval  = 0.785398163397448309615660845819875721d0-  &
        0.157079632679489661923132169163975144d1*dnu+  &
        0.535640519510615955699573863636363636d3/z**11-  &
        (0.253292660851912064985795454545454545d4*dnu**2)/z**11+  &
        (0.1641620853424072265625d4*dnu**4)/z**11-  &
        (0.32649652099609375d3*dnu**6)/z**11+  &
        (0.2351812744140625d2*dnu**8)/z**11-  &
        (0.54345703125d0*dnu**10)/z**11+  &
        (0.186434659090909090909090909090909091d-2*dnu**12)/z**11-  &
        0.234751277499728732638888888888888889d2/z**9+  &
        (0.1097091522216796875d3*dnu**2)/z**9-  &
        (0.658976101345486111111111111111111111d2*dnu**4)/z**9+  &
        (0.107744683159722222222222222222222222d2*dnu**6)/z**9-  &
        (0.489908854166666666666666666666666667d0*dnu**8)/z**9+  &
        (0.303819444444444444444444444444444444d-2*dnu**10)/z**9+  &
        0.163806588309151785714285714285714286d1/z**7-  &
        (0.750620814732142857142857142857142857d1*dnu**2)/z**7+  &
        (0.39228515625d1*dnu**4)/z**7-(0.4296875d0*dnu**6)/z**7+  &
        (0.558035714285714285714285714285714286d-2*dnu**8)/z**7-  &
        0.2095703125d0/z**5+(0.92734375d0*dnu**2)/z**5-  &
        (0.359375d0*dnu**4)/z**5+(0.125d-1*dnu**6)/z**5+  &
        0.651041666666666666666666666666666667d-1/z**3-  &
        (0.270833333333333333333333333333333333d0*dnu**2)/z**3+  &
        (0.416666666666666666666666666666666667d-1*dnu**4)/z**3-  &
        0.125d0/z+(0.5d0*dnu**2)/z+z

apval =  0.1d1-0.58920457146167755126953125d4/z**12+  &
        (0.278621926937103271484375d5*dnu**2)/z**12-  &
        (0.18057829387664794921875d5*dnu**4)/z**12+  &
        (0.359146173095703125d4*dnu**6)/z**12-  &
        (0.25869940185546875d3*dnu**8)/z**12+  &
        (0.597802734375d1*dnu**10)/z**12-  &
        (0.205078125d-1*dnu**12)/z**12+  &
        0.211276149749755859375d3/z**10-  &
        (0.9873823699951171875d3*dnu**2)/z**10+  &
        (0.5930784912109375d3*dnu**4)/z**10-  &
        (0.9697021484375d2*dnu**6)/z**10+  &
        (0.44091796875d1*dnu**8)/z**10-(0.2734375d-1*dnu**10)/z**10-  &
        0.11466461181640625d2/z**8+(0.5254345703125d2*dnu**2)/z**8-  &
        (0.274599609375d2*dnu**4)/z**8+(0.30078125d1*dnu**6)/z**8-  &
        (0.390625d-1*dnu**8)/z**8+0.10478515625d1/z**6-  &
        (0.463671875d1*dnu**2)/z**6+(0.1796875d1*dnu**4)/z**6-  &
        (0.625d-1*dnu**6)/z**6-0.1953125d0/z**4+  &
        (0.8125d0*dnu**2)/z**4-(0.125d0*dnu**4)/z**4+0.125d0/z**2-  &
        (0.5d0*dnu**2)/z**2


appval = 0.7070454857540130615234375d5/z**13-  &
        (0.33434631232452392578125d6*dnu**2)/z**13+  &
        (0.2166939526519775390625d6*dnu**4)/z**13-  &
        (0.43097540771484375d5*dnu**6)/z**13+  &
        (0.3104392822265625d4*dnu**8)/z**13-  &
        (0.71736328125d2*dnu**10)/z**13+(0.24609375d0*dnu**12)/z**13  &
        -0.211276149749755859375d4/z**11+  &
        (0.9873823699951171875d4*dnu**2)/z**11-  &
        (0.5930784912109375d4*dnu**4)/z**11+  &
        (0.9697021484375d3*dnu**6)/z**11-  &
        (0.44091796875d2*dnu**8)/z**11+(0.2734375d0*dnu**10)/z**11+  &
        0.91731689453125d2/z**9-(0.42034765625d3*dnu**2)/z**9+  &
        (0.2196796875d3*dnu**4)/z**9-(0.240625d2*dnu**6)/z**9+  &
        (0.3125d0*dnu**8)/z**9-0.6287109375d1/z**7+  &
        (0.278203125d2*dnu**2)/z**7-(0.1078125d2*dnu**4)/z**7+  &
        (0.375d0*dnu**6)/z**7+0.78125d0/z**5-(0.325d1*dnu**2)/z**5+  &
        (0.5d0*dnu**4)/z**5-0.25d0/z**3+dnu**2/z**3
end subroutine


end module
